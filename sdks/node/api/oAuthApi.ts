/**
 * The MIT License (MIT)
 *
 * Copyright (C) 2023 dropbox.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

import {
  Authentication,
  HttpBasicAuth,
  HttpBearerAuth,
  Interceptor,
  OAuthTokenGenerateRequest,
  OAuthTokenRefreshRequest,
  OAuthTokenResponse,
  ObjectSerializer,
  VoidAuth,
} from "../model";

import {
  generateFormData,
  HttpError,
  optionsI,
  queryParamsSerializer,
  returnTypeT,
  toFormData,
  USER_AGENT,
} from "./";

let defaultBasePath = "https://app.hellosign.com";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OAuthApiApiKeys {}

export class OAuthApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = { "User-Agent": USER_AGENT };
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    api_key: new HttpBasicAuth(),
    oauth2: new HttpBearerAuth(),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string) {
    if (basePath) {
      this.basePath = basePath;
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = { ...defaultHeaders, "User-Agent": USER_AGENT };
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: string) {
    this.authentications.api_key.username = key;
  }

  set username(username: string) {
    this.authentications.api_key.username = username;
  }

  set password(password: string) {
    this.authentications.api_key.password = password;
  }

  set accessToken(accessToken: string | (() => string)) {
    this.authentications.oauth2.accessToken = accessToken;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * Once you have retrieved the code from the user callback, you will need to exchange it for an access token via a backend call.
   * @summary OAuth Token Generate
   * @param oAuthTokenGenerateRequest
   * @param options
   */
  public async oauthTokenGenerate(
    oAuthTokenGenerateRequest: OAuthTokenGenerateRequest,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<OAuthTokenResponse>> {
    oAuthTokenGenerateRequest = deserializeIfNeeded(
      oAuthTokenGenerateRequest,
      "OAuthTokenGenerateRequest"
    );
    const localVarPath = this.basePath + "/oauth/token";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'oAuthTokenGenerateRequest' is not null or undefined
    if (
      oAuthTokenGenerateRequest === null ||
      oAuthTokenGenerateRequest === undefined
    ) {
      throw new Error(
        "Required parameter oAuthTokenGenerateRequest was null or undefined when calling oauthTokenGenerate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      oAuthTokenGenerateRequest,
      OAuthTokenGenerateRequest.attributeTypeMap
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(
        oAuthTokenGenerateRequest,
        "OAuthTokenGenerateRequest"
      );
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "POST",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<OAuthTokenResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            handleSuccessfulResponse<OAuthTokenResponse>(
              resolve,
              reject,
              response,
              "OAuthTokenResponse"
            );
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            if (
              handleErrorCodeResponse(
                reject,
                error.response,
                200,
                "OAuthTokenResponse"
              )
            ) {
              return;
            }

            if (
              handleErrorRangeResponse(
                reject,
                error.response,
                "4XX",
                "ErrorResponse"
              )
            ) {
              return;
            }

            reject(error);
          }
        );
      });
    });
  }
  /**
   * Access tokens are only valid for a given period of time (typically one hour) for security reasons. Whenever acquiring an new access token its TTL is also given (see `expires_in`), along with a refresh token that can be used to acquire a new access token after the current one has expired.
   * @summary OAuth Token Refresh
   * @param oAuthTokenRefreshRequest
   * @param options
   */
  public async oauthTokenRefresh(
    oAuthTokenRefreshRequest: OAuthTokenRefreshRequest,
    options: optionsI = { headers: {} }
  ): Promise<returnTypeT<OAuthTokenResponse>> {
    oAuthTokenRefreshRequest = deserializeIfNeeded(
      oAuthTokenRefreshRequest,
      "OAuthTokenRefreshRequest"
    );
    const localVarPath = this.basePath + "/oauth/token?refresh";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams["content-type"] = "application/json";
    } else {
      localVarHeaderParams["content-type"] = produces.join(",");
    }
    let localVarFormParams: any = {};
    let localVarBodyParams: any = undefined;

    // verify required parameter 'oAuthTokenRefreshRequest' is not null or undefined
    if (
      oAuthTokenRefreshRequest === null ||
      oAuthTokenRefreshRequest === undefined
    ) {
      throw new Error(
        "Required parameter oAuthTokenRefreshRequest was null or undefined when calling oauthTokenRefresh."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    const result = generateFormData(
      oAuthTokenRefreshRequest,
      OAuthTokenRefreshRequest.attributeTypeMap
    );
    localVarUseFormData = result.localVarUseFormData;

    let data = {};
    if (localVarUseFormData) {
      const formData = toFormData(result.data);
      data = formData;
      localVarHeaderParams = {
        ...localVarHeaderParams,
        ...formData.getHeaders(),
      };
    } else {
      data = ObjectSerializer.serialize(
        oAuthTokenRefreshRequest,
        "OAuthTokenRefreshRequest"
      );
    }

    let localVarRequestOptions: AxiosRequestConfig = {
      method: "POST",
      params: localVarQueryParameters,
      headers: localVarHeaderParams,
      url: localVarPath,
      paramsSerializer: this._useQuerystring
        ? queryParamsSerializer
        : undefined,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      responseType: "json",
      data,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      return new Promise<returnTypeT<OAuthTokenResponse>>((resolve, reject) => {
        axios.request(localVarRequestOptions).then(
          (response) => {
            handleSuccessfulResponse<OAuthTokenResponse>(
              resolve,
              reject,
              response,
              "OAuthTokenResponse"
            );
          },
          (error: AxiosError) => {
            if (error.response == null) {
              reject(error);
              return;
            }

            if (
              handleErrorCodeResponse(
                reject,
                error.response,
                200,
                "OAuthTokenResponse"
              )
            ) {
              return;
            }

            if (
              handleErrorRangeResponse(
                reject,
                error.response,
                "4XX",
                "ErrorResponse"
              )
            ) {
              return;
            }

            reject(error);
          }
        );
      });
    });
  }
}

function deserializeIfNeeded<T>(obj: T, classname: string): T {
  if (obj !== null && obj !== undefined && obj.constructor.name !== classname) {
    return ObjectSerializer.deserialize(obj, classname);
  }

  return obj;
}

type AxiosResolve<T> = (
  value: returnTypeT<T> | PromiseLike<returnTypeT<T>>
) => void;

type AxiosReject = (reason?: any) => void;

function handleSuccessfulResponse<T>(
  resolve: AxiosResolve<T>,
  reject: AxiosReject,
  response: AxiosResponse,
  returnType?: string
) {
  let body = response.data;

  if (response.status && response.status >= 200 && response.status <= 299) {
    if (returnType) {
      body = ObjectSerializer.deserialize(body, returnType);
    }

    resolve({ response: response, body: body });
  } else {
    reject(new HttpError(response, body, response.status));
  }
}

function handleErrorCodeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: number,
  returnType: string
): boolean {
  if (response.status !== code) {
    return false;
  }

  const body = ObjectSerializer.deserialize(response.data, returnType);

  reject(new HttpError(response, body, response.status));

  return true;
}

function handleErrorRangeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: string,
  returnType: string
): boolean {
  let rangeCodeLeft = Number(code[0] + "00");
  let rangeCodeRight = Number(code[0] + "99");

  if (response.status >= rangeCodeLeft && response.status <= rangeCodeRight) {
    const body = ObjectSerializer.deserialize(response.data, returnType);

    reject(new HttpError(response, body, response.status));

    return true;
  }

  return false;
}
