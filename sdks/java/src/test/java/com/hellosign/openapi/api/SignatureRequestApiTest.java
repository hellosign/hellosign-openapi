/*
 * HelloSign API
 * HelloSign v3 API
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: apisupport@hellosign.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.hellosign.openapi.api;

import com.hellosign.openapi.ApiClient;
import com.hellosign.openapi.ApiException;
import com.hellosign.openapi.TestHelper;
import com.hellosign.openapi.auth.*;
import com.hellosign.openapi.model.*;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mockito;


import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;

/**
 * API tests for SignatureRequestApi
 */
public class SignatureRequestApiTest {

    /**
     * Creates BulkSendJob which sends SignatureRequests in bulk based off of the provided Template(s) to be signed in an embedded window.
     *
     * Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on HelloSign.  **NOTE**: Only available for Gold plan and higher.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestBulkCreateEmbeddedWithTemplateTest() throws Exception {
        SignatureRequestBulkCreateEmbeddedWithTemplateRequest request = TestHelper.getFixtureData(SignatureRequestBulkCreateEmbeddedWithTemplateRequest.class, "default");
        BulkSendJobSendResponse expected = TestHelper.getFixtureData(BulkSendJobSendResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        BulkSendJobSendResponse actual = api.signatureRequestBulkCreateEmbeddedWithTemplate(request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Creates BulkSendJob which sends SignatureRequests in bulk based off of the provided Template(s).
     *
     * Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Gold plan and higher.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestBulkSendWithTemplateTest() throws Exception {
        SignatureRequestBulkSendWithTemplateRequest request = TestHelper.getFixtureData(SignatureRequestBulkSendWithTemplateRequest.class, "default");
        BulkSendJobSendResponse expected = TestHelper.getFixtureData(BulkSendJobSendResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        BulkSendJobSendResponse actual = api.signatureRequestBulkSendWithTemplate(request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Cancels an incomplete SignatureRequest.
     *
     * Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](https://app.hellosign.com/api/eventsAndCallbacksWalkthrough) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestCancelTest() throws ApiException {
        //String signatureRequestId = null;
        //api.signatureRequestCancel(signatureRequestId);
        // TODO: test validations
    }

    /**
     * Creates a new SignatureRequest to be signed in an embedded window.
     *
     * Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on HelloSign.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestCreateEmbeddedTest() throws Exception {
        SignatureRequestCreateEmbeddedRequest request = TestHelper.getFixtureData(SignatureRequestCreateEmbeddedRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestCreateEmbedded(request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Creates and sends a new SignatureRequest based off of the provided Template(s).
     *
     * Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on HelloSign.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestCreateEmbeddedWithTemplateTest() throws Exception {
        SignatureRequestCreateEmbeddedWithTemplateRequest request = TestHelper.getFixtureData(SignatureRequestCreateEmbeddedWithTemplateRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestCreateEmbeddedWithTemplate(request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Obtain a copy of the current documents.
     *
     * Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter.  Returns a PDF or ZIP file, or if &#x60;get_url&#x60; is set, a JSON object with a url to the file (PDFs only). If &#x60;get_data_uri&#x60; is set, a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only) is returned.  If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestFilesTest() throws Exception {
        // TODO: test validations
    }

    /**
     * Gets a SignatureRequest that includes the current status for each signer.
     *
     * Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestGetTest() throws Exception {
        String signatureRequestId = "fa5c8a0b0f492d768749333ad6fcc214c111e967";

        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestGet(signatureRequestId);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Lists the SignatureRequests (both inbound and outbound) that you have access to.
     *
     * Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](https://app.hellosign.com/api/reference#Search) to learn more about querying signature requests.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestListTest() throws Exception {
        String accountId = "all";
        SignatureRequestListResponse expected = TestHelper.getFixtureData(SignatureRequestListResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestListResponse actual = api.signatureRequestList(accountId, 1, 20, null);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Releases a SignatureRequest from hold.
     *
     * Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](https://app.hellosign.com/api/reference#UnclaimedDraft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestReleaseHoldTest() throws Exception {
        String signatureRequestId = "fa5c8a0b0f492d768749333ad6fcc214c111e967";

        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestReleaseHold(signatureRequestId);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Sends an email to the signer reminding them to sign the signature request.
     *
     * Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestRemindTest() throws Exception {
        String signatureRequestId = "fa5c8a0b0f492d768749333ad6fcc214c111e967";

        SignatureRequestRemindRequest request = TestHelper.getFixtureData(SignatureRequestRemindRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestRemind(signatureRequestId, request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Remove access to a completed SignatureRequest.
     *
     * Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestRemoveTest() throws ApiException {
        //String signatureRequestId = null;
        //api.signatureRequestRemove(signatureRequestId);
        // TODO: test validations
    }

    /**
     * Creates and sends a new SignatureRequest with the submitted documents.
     *
     * Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestSendTest() throws Exception {
        SignatureRequestSendRequest request = TestHelper.getFixtureData(SignatureRequestSendRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestSend(request);
        Assert.assertEquals(expected, actual);
    }

    @Test
    public void signatureRequestSendFileForcesMultipartFormDataTest() throws Exception {
        SignatureRequestSendRequest request = TestHelper.getFixtureData(SignatureRequestSendRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        api.signatureRequestSend(request);
        Mockito.verify(apiClient).invokeAPI(any(), any(), any(), any(), any(), any(), any(), any(), any(), eq("multipart/form-data"), any(), any(), eq(false));
    }

    @Test
    public void signatureRequestSendNoFileForcesApplicationJsonTest() throws Exception {
        SignatureRequestSendRequest request = TestHelper.getFixtureData(SignatureRequestSendRequest.class, "with_file_url");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        api.signatureRequestSend(request);
        Mockito.verify(apiClient).invokeAPI(any(), any(), any(), any(), any(), any(), any(), any(), any(), eq("application/json"), any(), any(), eq(false));
    }

    /**
     * Creates and sends a new SignatureRequest based off of one or more Templates.
     *
     * Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestSendWithTemplateTest() throws Exception {
        SignatureRequestSendWithTemplateRequest request = TestHelper.getFixtureData(SignatureRequestSendWithTemplateRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestSendWithTemplate(request);
        Assert.assertEquals(expected, actual);
    }

    /**
     * Update an email address on a signature request.
     *
     * Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void signatureRequestUpdateTest() throws Exception {
        String signatureRequestId = "fa5c8a0b0f492d768749333ad6fcc214c111e967";

        SignatureRequestUpdateRequest request = TestHelper.getFixtureData(SignatureRequestUpdateRequest.class, "default");
        SignatureRequestGetResponse expected = TestHelper.getFixtureData(SignatureRequestGetResponse.class, "default");
        ApiClient apiClient = TestHelper.setUpMock(200, expected);
        SignatureRequestApi api = new SignatureRequestApi(apiClient);
        SignatureRequestGetResponse actual = api.signatureRequestUpdate(signatureRequestId, request);
        Assert.assertEquals(expected, actual);
    }

}
