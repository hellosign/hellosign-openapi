class {{classname}}(ModelComposed):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Attributes:
{{> model_templates/docstring_allowed }}
      attribute_map (dict): The key is attribute name
          and the value is json key in definition.
      discriminator_value_class_map (dict): A dict to go from the discriminator
          variable value to the discriminator class name.
{{> model_templates/docstring_openapi_validations }}
    """

{{> model_templates/classvars }}

    attribute_map = {
{{#requiredVars}}
        '{{name}}': '{{baseName}}',  # noqa: E501
{{/requiredVars}}
{{#optionalVars}}
        '{{name}}': '{{baseName}}',  # noqa: E501
{{/optionalVars}}
    }

    read_only_vars = {
{{#requiredVars}}
{{#isReadOnly}}
        '{{name}}',  # noqa: E501
{{/isReadOnly}}
{{/requiredVars}}
{{#optionalVars}}
{{#isReadOnly}}
        '{{name}}',  # noqa: E501
{{/isReadOnly}}
{{/optionalVars}}
    }
    {{#requiredVars}}

    @property
    def {{name}}(self) -> {{#vendorExtensions.x-int-or-string}}Union[int, str]{{/vendorExtensions.x-int-or-string}}{{^vendorExtensions.x-int-or-string}}{{{dataType}}}{{/vendorExtensions.x-int-or-string}}:
        return self.get("{{name}}")
    {{^isReadOnly}}

    @{{name}}.setter
    def {{name}}(self, value: {{#vendorExtensions.x-int-or-string}}Union[int, str]{{/vendorExtensions.x-int-or-string}}{{^vendorExtensions.x-int-or-string}}{{{dataType}}}{{/vendorExtensions.x-int-or-string}}):
        setattr(self, "{{name}}", value)
    {{/isReadOnly}}
    {{/requiredVars}}
    {{#optionalVars}}

    @property
    def {{name}}(self) -> {{{dataType}}}:
        return self.get("{{name}}")

    @{{name}}.setter
    def {{name}}(self, value: {{{dataType}}}):
        setattr(self, "{{name}}", value)
    {{/optionalVars}}

{{> model_templates/method_from_openapi_data_composed }}

{{> model_templates/method_init_composed }}

    @cached_property
    def _composed_schemas():
        # we need this here to make our import statements work
        # we must store _composed_schemas in here so the code is only run
        # when we invoke this method. If we kept this at the class
        # level we would get an error because the class level
        # code would be run when this module is imported, and these composed
        # classes don't exist yet because their module has not finished
        # loading
{{#imports}}
{{#-first}}
        lazy_import()
{{/-first}}
{{/imports}}
        return {
          'anyOf': [
{{#anyOf}}
              {{{.}}},
{{/anyOf}}
          ],
          'oneOf': [
{{#oneOf}}
              {{{.}}},
{{/oneOf}}
          ],
        }