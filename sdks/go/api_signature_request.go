/*
Dropbox Sign API

Dropbox Sign v3 API

API version: 3.0.0
Contact: apisupport@hellosign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dropbox_sign

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// SignatureRequestAPIService SignatureRequestAPI service
type SignatureRequestAPIService service

type ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestBulkCreateEmbeddedWithTemplateRequest *SignatureRequestBulkCreateEmbeddedWithTemplateRequest
}

func (r ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest) SignatureRequestBulkCreateEmbeddedWithTemplateRequest(signatureRequestBulkCreateEmbeddedWithTemplateRequest SignatureRequestBulkCreateEmbeddedWithTemplateRequest) ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest {
	r.signatureRequestBulkCreateEmbeddedWithTemplateRequest = &signatureRequestBulkCreateEmbeddedWithTemplateRequest
	return r
}

func (r ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest) Execute() (*BulkSendJobSendResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestBulkCreateEmbeddedWithTemplateExecute(r)
}

/*
SignatureRequestBulkCreateEmbeddedWithTemplate Embedded Bulk Send with Template

Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the `template_ids` parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.

**NOTE**: Only available for Standard plan and higher.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestBulkCreateEmbeddedWithTemplate(ctx context.Context) ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest {
	return ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkSendJobSendResponse
func (a *SignatureRequestAPIService) SignatureRequestBulkCreateEmbeddedWithTemplateExecute(r ApiSignatureRequestBulkCreateEmbeddedWithTemplateRequest) (*BulkSendJobSendResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkSendJobSendResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestBulkCreateEmbeddedWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/bulk_create_embedded_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestBulkCreateEmbeddedWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestBulkCreateEmbeddedWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestBulkCreateEmbeddedWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestBulkSendWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestBulkSendWithTemplateRequest *SignatureRequestBulkSendWithTemplateRequest
}

func (r ApiSignatureRequestBulkSendWithTemplateRequest) SignatureRequestBulkSendWithTemplateRequest(signatureRequestBulkSendWithTemplateRequest SignatureRequestBulkSendWithTemplateRequest) ApiSignatureRequestBulkSendWithTemplateRequest {
	r.signatureRequestBulkSendWithTemplateRequest = &signatureRequestBulkSendWithTemplateRequest
	return r
}

func (r ApiSignatureRequestBulkSendWithTemplateRequest) Execute() (*BulkSendJobSendResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestBulkSendWithTemplateExecute(r)
}

/*
SignatureRequestBulkSendWithTemplate Bulk Send with Template

Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the `template_ids` parameter.

**NOTE**: Only available for Standard plan and higher.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestBulkSendWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestBulkSendWithTemplate(ctx context.Context) ApiSignatureRequestBulkSendWithTemplateRequest {
	return ApiSignatureRequestBulkSendWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkSendJobSendResponse
func (a *SignatureRequestAPIService) SignatureRequestBulkSendWithTemplateExecute(r ApiSignatureRequestBulkSendWithTemplateRequest) (*BulkSendJobSendResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkSendJobSendResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestBulkSendWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/bulk_send_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestBulkSendWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestBulkSendWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestBulkSendWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestCancelRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
}

func (r ApiSignatureRequestCancelRequest) Execute() (*http.Response, error) {
	return r.ApiService.SignatureRequestCancelExecute(r)
}

/*
SignatureRequestCancel Cancel Incomplete Signature Request

Cancels an incomplete signature request. This action is **not reversible**.

The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.

This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the `signature_request_canceled` event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the `signature_request_canceled` event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.

To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.

**NOTE**: To remove your access to a completed signature request, use the endpoint: `POST /signature_request/remove/[:signature_request_id]`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the incomplete SignatureRequest to cancel.
 @return ApiSignatureRequestCancelRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestCancel(ctx context.Context, signatureRequestId string) ApiSignatureRequestCancelRequest {
	return ApiSignatureRequestCancelRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
func (a *SignatureRequestAPIService) SignatureRequestCancelExecute(r ApiSignatureRequestCancelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestCancel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/cancel/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSignatureRequestCreateEmbeddedRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestCreateEmbeddedRequest *SignatureRequestCreateEmbeddedRequest
}

func (r ApiSignatureRequestCreateEmbeddedRequest) SignatureRequestCreateEmbeddedRequest(signatureRequestCreateEmbeddedRequest SignatureRequestCreateEmbeddedRequest) ApiSignatureRequestCreateEmbeddedRequest {
	r.signatureRequestCreateEmbeddedRequest = &signatureRequestCreateEmbeddedRequest
	return r
}

func (r ApiSignatureRequestCreateEmbeddedRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestCreateEmbeddedExecute(r)
}

/*
SignatureRequestCreateEmbedded Create Embedded Signature Request

Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. <u>Note</u> that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestCreateEmbeddedRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestCreateEmbedded(ctx context.Context) ApiSignatureRequestCreateEmbeddedRequest {
	return ApiSignatureRequestCreateEmbeddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestCreateEmbeddedExecute(r ApiSignatureRequestCreateEmbeddedRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestCreateEmbedded")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/create_embedded"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestCreateEmbeddedRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestCreateEmbeddedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestCreateEmbeddedRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestCreateEmbeddedWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestCreateEmbeddedWithTemplateRequest *SignatureRequestCreateEmbeddedWithTemplateRequest
}

func (r ApiSignatureRequestCreateEmbeddedWithTemplateRequest) SignatureRequestCreateEmbeddedWithTemplateRequest(signatureRequestCreateEmbeddedWithTemplateRequest SignatureRequestCreateEmbeddedWithTemplateRequest) ApiSignatureRequestCreateEmbeddedWithTemplateRequest {
	r.signatureRequestCreateEmbeddedWithTemplateRequest = &signatureRequestCreateEmbeddedWithTemplateRequest
	return r
}

func (r ApiSignatureRequestCreateEmbeddedWithTemplateRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestCreateEmbeddedWithTemplateExecute(r)
}

/*
SignatureRequestCreateEmbeddedWithTemplate Create Embedded Signature Request with Template

Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. <u>Note</u> that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestCreateEmbeddedWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestCreateEmbeddedWithTemplate(ctx context.Context) ApiSignatureRequestCreateEmbeddedWithTemplateRequest {
	return ApiSignatureRequestCreateEmbeddedWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestCreateEmbeddedWithTemplateExecute(r ApiSignatureRequestCreateEmbeddedWithTemplateRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestCreateEmbeddedWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/create_embedded_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestCreateEmbeddedWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestCreateEmbeddedWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestCreateEmbeddedWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestEditRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestEditRequest *SignatureRequestEditRequest
}

func (r ApiSignatureRequestEditRequest) SignatureRequestEditRequest(signatureRequestEditRequest SignatureRequestEditRequest) ApiSignatureRequestEditRequest {
	r.signatureRequestEditRequest = &signatureRequestEditRequest
	return r
}

func (r ApiSignatureRequestEditRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestEditExecute(r)
}

/*
SignatureRequestEdit Edit Signature Request

Edits and sends a SignatureRequest with the submitted documents. If `form_fields_per_document` is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.

**NOTE:** Edit and resend will not deduct your signature request quota.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to edit.
 @return ApiSignatureRequestEditRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestEdit(ctx context.Context, signatureRequestId string) ApiSignatureRequestEditRequest {
	return ApiSignatureRequestEditRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestEditExecute(r ApiSignatureRequestEditRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/edit/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestEditRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestEditRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestEditRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestEditEmbeddedRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestEditEmbeddedRequest *SignatureRequestEditEmbeddedRequest
}

func (r ApiSignatureRequestEditEmbeddedRequest) SignatureRequestEditEmbeddedRequest(signatureRequestEditEmbeddedRequest SignatureRequestEditEmbeddedRequest) ApiSignatureRequestEditEmbeddedRequest {
	r.signatureRequestEditEmbeddedRequest = &signatureRequestEditEmbeddedRequest
	return r
}

func (r ApiSignatureRequestEditEmbeddedRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestEditEmbeddedExecute(r)
}

/*
SignatureRequestEditEmbedded Edit Embedded Signature Request

Edits a SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. <u>Note</u> that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to edit.
 @return ApiSignatureRequestEditEmbeddedRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestEditEmbedded(ctx context.Context, signatureRequestId string) ApiSignatureRequestEditEmbeddedRequest {
	return ApiSignatureRequestEditEmbeddedRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestEditEmbeddedExecute(r ApiSignatureRequestEditEmbeddedRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestEditEmbedded")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/edit_embedded/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestEditEmbeddedRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestEditEmbeddedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestEditEmbeddedRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestEditEmbeddedWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestEditEmbeddedWithTemplateRequest *SignatureRequestEditEmbeddedWithTemplateRequest
}

func (r ApiSignatureRequestEditEmbeddedWithTemplateRequest) SignatureRequestEditEmbeddedWithTemplateRequest(signatureRequestEditEmbeddedWithTemplateRequest SignatureRequestEditEmbeddedWithTemplateRequest) ApiSignatureRequestEditEmbeddedWithTemplateRequest {
	r.signatureRequestEditEmbeddedWithTemplateRequest = &signatureRequestEditEmbeddedWithTemplateRequest
	return r
}

func (r ApiSignatureRequestEditEmbeddedWithTemplateRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestEditEmbeddedWithTemplateExecute(r)
}

/*
SignatureRequestEditEmbeddedWithTemplate Edit Embedded Signature Request with Template

Edits a SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. <u>Note</u> that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to edit.
 @return ApiSignatureRequestEditEmbeddedWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestEditEmbeddedWithTemplate(ctx context.Context, signatureRequestId string) ApiSignatureRequestEditEmbeddedWithTemplateRequest {
	return ApiSignatureRequestEditEmbeddedWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestEditEmbeddedWithTemplateExecute(r ApiSignatureRequestEditEmbeddedWithTemplateRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestEditEmbeddedWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/edit_embedded_with_template/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestEditEmbeddedWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestEditEmbeddedWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestEditEmbeddedWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestEditWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestEditWithTemplateRequest *SignatureRequestEditWithTemplateRequest
}

func (r ApiSignatureRequestEditWithTemplateRequest) SignatureRequestEditWithTemplateRequest(signatureRequestEditWithTemplateRequest SignatureRequestEditWithTemplateRequest) ApiSignatureRequestEditWithTemplateRequest {
	r.signatureRequestEditWithTemplateRequest = &signatureRequestEditWithTemplateRequest
	return r
}

func (r ApiSignatureRequestEditWithTemplateRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestEditWithTemplateExecute(r)
}

/*
SignatureRequestEditWithTemplate Edit Signature Request With Template

Edits and sends a SignatureRequest based off of the Template(s) specified with the template_ids parameter.

**NOTE:** Edit and resend will not deduct your signature request quota.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to edit.
 @return ApiSignatureRequestEditWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestEditWithTemplate(ctx context.Context, signatureRequestId string) ApiSignatureRequestEditWithTemplateRequest {
	return ApiSignatureRequestEditWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestEditWithTemplateExecute(r ApiSignatureRequestEditWithTemplateRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestEditWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/edit_with_template/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestEditWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestEditWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestEditWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestFilesRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	fileType *string
}

// Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents.
func (r ApiSignatureRequestFilesRequest) FileType(fileType string) ApiSignatureRequestFilesRequest {
	r.fileType = &fileType
	return r
}

func (r ApiSignatureRequestFilesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.SignatureRequestFilesExecute(r)
}

/*
SignatureRequestFiles Download Files

Obtain a copy of the current documents specified by the `signature_request_id` parameter. Returns a PDF or ZIP file.

If the files are currently being prepared, a status code of `409` will be returned instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to retrieve.
 @return ApiSignatureRequestFilesRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestFiles(ctx context.Context, signatureRequestId string) ApiSignatureRequestFilesRequest {
	return ApiSignatureRequestFilesRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SignatureRequestAPIService) SignatureRequestFilesExecute(r ApiSignatureRequestFilesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/files/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_type", r.fileType, "")
	} else {
		var defaultValue string = "pdf"
		r.fileType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestFilesAsDataUriRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
}

func (r ApiSignatureRequestFilesAsDataUriRequest) Execute() (*FileResponseDataUri, *http.Response, error) {
	return r.ApiService.SignatureRequestFilesAsDataUriExecute(r)
}

/*
SignatureRequestFilesAsDataUri Download Files as Data Uri

Obtain a copy of the current documents specified by the `signature_request_id` parameter. Returns a JSON object with a `data_uri` representing the base64 encoded file (PDFs only).

If the files are currently being prepared, a status code of `409` will be returned instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to retrieve.
 @return ApiSignatureRequestFilesAsDataUriRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestFilesAsDataUri(ctx context.Context, signatureRequestId string) ApiSignatureRequestFilesAsDataUriRequest {
	return ApiSignatureRequestFilesAsDataUriRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return FileResponseDataUri
func (a *SignatureRequestAPIService) SignatureRequestFilesAsDataUriExecute(r ApiSignatureRequestFilesAsDataUriRequest) (*FileResponseDataUri, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileResponseDataUri
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestFilesAsDataUri")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/files_as_data_uri/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestFilesAsFileUrlRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	forceDownload *int32
}

// By default when opening the &#x60;file_url&#x60; a browser will download the PDF and save it locally. When set to &#x60;0&#x60; the PDF file will be displayed in the browser.
func (r ApiSignatureRequestFilesAsFileUrlRequest) ForceDownload(forceDownload int32) ApiSignatureRequestFilesAsFileUrlRequest {
	r.forceDownload = &forceDownload
	return r
}

func (r ApiSignatureRequestFilesAsFileUrlRequest) Execute() (*FileResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestFilesAsFileUrlExecute(r)
}

/*
SignatureRequestFilesAsFileUrl Download Files as File Url

Obtain a copy of the current documents specified by the `signature_request_id` parameter. Returns a JSON object with a url to the file (PDFs only).

If the files are currently being prepared, a status code of `409` will be returned instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to retrieve.
 @return ApiSignatureRequestFilesAsFileUrlRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestFilesAsFileUrl(ctx context.Context, signatureRequestId string) ApiSignatureRequestFilesAsFileUrlRequest {
	return ApiSignatureRequestFilesAsFileUrlRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return FileResponse
func (a *SignatureRequestAPIService) SignatureRequestFilesAsFileUrlExecute(r ApiSignatureRequestFilesAsFileUrlRequest) (*FileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestFilesAsFileUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/files_as_file_url/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force_download", r.forceDownload, "")
	} else {
		var defaultValue int32 = 1
		r.forceDownload = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestGetRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
}

func (r ApiSignatureRequestGetRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestGetExecute(r)
}

/*
SignatureRequestGet Get Signature Request

Returns the status of the SignatureRequest specified by the `signature_request_id` parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to retrieve.
 @return ApiSignatureRequestGetRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestGet(ctx context.Context, signatureRequestId string) ApiSignatureRequestGetRequest {
	return ApiSignatureRequestGetRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestGetExecute(r ApiSignatureRequestGetRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestListRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	accountId *string
	page *int32
	pageSize *int32
	query *string
}

// Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account.
func (r ApiSignatureRequestListRequest) AccountId(accountId string) ApiSignatureRequestListRequest {
	r.accountId = &accountId
	return r
}

// Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;.
func (r ApiSignatureRequestListRequest) Page(page int32) ApiSignatureRequestListRequest {
	r.page = &page
	return r
}

// Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;.
func (r ApiSignatureRequestListRequest) PageSize(pageSize int32) ApiSignatureRequestListRequest {
	r.pageSize = &pageSize
	return r
}

// String that includes search terms and/or fields to be used to filter the SignatureRequest objects.
func (r ApiSignatureRequestListRequest) Query(query string) ApiSignatureRequestListRequest {
	r.query = &query
	return r
}

func (r ApiSignatureRequestListRequest) Execute() (*SignatureRequestListResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestListExecute(r)
}

/*
SignatureRequestList List Signature Requests

Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.

Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestListRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestList(ctx context.Context) ApiSignatureRequestListRequest {
	return ApiSignatureRequestListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignatureRequestListResponse
func (a *SignatureRequestAPIService) SignatureRequestListExecute(r ApiSignatureRequestListRequest) (*SignatureRequestListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestReleaseHoldRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
}

func (r ApiSignatureRequestReleaseHoldRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestReleaseHoldExecute(r)
}

/*
SignatureRequestReleaseHold Release On-Hold Signature Request

Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to release.
 @return ApiSignatureRequestReleaseHoldRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestReleaseHold(ctx context.Context, signatureRequestId string) ApiSignatureRequestReleaseHoldRequest {
	return ApiSignatureRequestReleaseHoldRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestReleaseHoldExecute(r ApiSignatureRequestReleaseHoldRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestReleaseHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/release_hold/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestRemindRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestRemindRequest *SignatureRequestRemindRequest
}

func (r ApiSignatureRequestRemindRequest) SignatureRequestRemindRequest(signatureRequestRemindRequest SignatureRequestRemindRequest) ApiSignatureRequestRemindRequest {
	r.signatureRequestRemindRequest = &signatureRequestRemindRequest
	return r
}

func (r ApiSignatureRequestRemindRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestRemindExecute(r)
}

/*
SignatureRequestRemind Send Request Reminder

Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.

**NOTE**: This action can **not** be used with embedded signature requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to send a reminder for.
 @return ApiSignatureRequestRemindRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestRemind(ctx context.Context, signatureRequestId string) ApiSignatureRequestRemindRequest {
	return ApiSignatureRequestRemindRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestRemindExecute(r ApiSignatureRequestRemindRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestRemind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/remind/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestRemindRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestRemindRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestRemindRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestRemoveRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
}

func (r ApiSignatureRequestRemoveRequest) Execute() (*http.Response, error) {
	return r.ApiService.SignatureRequestRemoveExecute(r)
}

/*
SignatureRequestRemove Remove Signature Request Access

Removes your access to a completed signature request. This action is **not reversible**.

The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).

Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to remove.
 @return ApiSignatureRequestRemoveRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestRemove(ctx context.Context, signatureRequestId string) ApiSignatureRequestRemoveRequest {
	return ApiSignatureRequestRemoveRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
func (a *SignatureRequestAPIService) SignatureRequestRemoveExecute(r ApiSignatureRequestRemoveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestRemove")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/remove/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSignatureRequestSendRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestSendRequest *SignatureRequestSendRequest
}

func (r ApiSignatureRequestSendRequest) SignatureRequestSendRequest(signatureRequestSendRequest SignatureRequestSendRequest) ApiSignatureRequestSendRequest {
	r.signatureRequestSendRequest = &signatureRequestSendRequest
	return r
}

func (r ApiSignatureRequestSendRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestSendExecute(r)
}

/*
SignatureRequestSend Send Signature Request

Creates and sends a new SignatureRequest with the submitted documents. If `form_fields_per_document` is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestSendRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestSend(ctx context.Context) ApiSignatureRequestSendRequest {
	return ApiSignatureRequestSendRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestSendExecute(r ApiSignatureRequestSendRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestSend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/send"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestSendRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestSendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestSendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestSendWithTemplateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestSendWithTemplateRequest *SignatureRequestSendWithTemplateRequest
}

func (r ApiSignatureRequestSendWithTemplateRequest) SignatureRequestSendWithTemplateRequest(signatureRequestSendWithTemplateRequest SignatureRequestSendWithTemplateRequest) ApiSignatureRequestSendWithTemplateRequest {
	r.signatureRequestSendWithTemplateRequest = &signatureRequestSendWithTemplateRequest
	return r
}

func (r ApiSignatureRequestSendWithTemplateRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestSendWithTemplateExecute(r)
}

/*
SignatureRequestSendWithTemplate Send with Template

Creates and sends a new SignatureRequest based off of the Template(s) specified with the `template_ids` parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSignatureRequestSendWithTemplateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestSendWithTemplate(ctx context.Context) ApiSignatureRequestSendWithTemplateRequest {
	return ApiSignatureRequestSendWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestSendWithTemplateExecute(r ApiSignatureRequestSendWithTemplateRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestSendWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/send_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestSendWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestSendWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestSendWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignatureRequestUpdateRequest struct {
	ctx context.Context
	ApiService *SignatureRequestAPIService
	signatureRequestId string
	signatureRequestUpdateRequest *SignatureRequestUpdateRequest
}

func (r ApiSignatureRequestUpdateRequest) SignatureRequestUpdateRequest(signatureRequestUpdateRequest SignatureRequestUpdateRequest) ApiSignatureRequestUpdateRequest {
	r.signatureRequestUpdateRequest = &signatureRequestUpdateRequest
	return r
}

func (r ApiSignatureRequestUpdateRequest) Execute() (*SignatureRequestGetResponse, *http.Response, error) {
	return r.ApiService.SignatureRequestUpdateExecute(r)
}

/*
SignatureRequestUpdate Update Signature Request

Updates the email address and/or the name for a given signer on a signature request. You can listen for the `signature_request_email_bounce` event on your app or account to detect bounced emails, and respond with this method.

Updating the email address of a signer will generate a new `signature_id` value.

**NOTE**: This action cannot be performed on a signature request with an appended signature page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The id of the SignatureRequest to update.
 @return ApiSignatureRequestUpdateRequest
*/
func (a *SignatureRequestAPIService) SignatureRequestUpdate(ctx context.Context, signatureRequestId string) ApiSignatureRequestUpdateRequest {
	return ApiSignatureRequestUpdateRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return SignatureRequestGetResponse
func (a *SignatureRequestAPIService) SignatureRequestUpdateExecute(r ApiSignatureRequestUpdateRequest) (*SignatureRequestGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureRequestGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignatureRequestAPIService.SignatureRequestUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signature_request/update/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signatureRequestUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("signatureRequestUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signatureRequestUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
