/*
Dropbox Sign API

Dropbox Sign v3 API

API version: 3.0.0
Contact: apisupport@hellosign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dropbox_sign

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UnclaimedDraftAPIService UnclaimedDraftAPI service
type UnclaimedDraftAPIService service

type ApiUnclaimedDraftCreateRequest struct {
	ctx context.Context
	ApiService *UnclaimedDraftAPIService
	unclaimedDraftCreateRequest *UnclaimedDraftCreateRequest
}

func (r ApiUnclaimedDraftCreateRequest) UnclaimedDraftCreateRequest(unclaimedDraftCreateRequest UnclaimedDraftCreateRequest) ApiUnclaimedDraftCreateRequest {
	r.unclaimedDraftCreateRequest = &unclaimedDraftCreateRequest
	return r
}

func (r ApiUnclaimedDraftCreateRequest) Execute() (*UnclaimedDraftCreateResponse, *http.Response, error) {
	return r.ApiService.UnclaimedDraftCreateExecute(r)
}

/*
UnclaimedDraftCreate Create Unclaimed Draft

Creates a new Draft that can be claimed using the claim URL. The first authenticated user to access the URL will claim the Draft and will be shown either the "Sign and send" or the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnclaimedDraftCreateRequest
*/
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreate(ctx context.Context) ApiUnclaimedDraftCreateRequest {
	return ApiUnclaimedDraftCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreateExecute(r ApiUnclaimedDraftCreateRequest) (*UnclaimedDraftCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftAPIService.UnclaimedDraftCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unclaimedDraftCreateRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnclaimedDraftCreateEmbeddedRequest struct {
	ctx context.Context
	ApiService *UnclaimedDraftAPIService
	unclaimedDraftCreateEmbeddedRequest *UnclaimedDraftCreateEmbeddedRequest
}

func (r ApiUnclaimedDraftCreateEmbeddedRequest) UnclaimedDraftCreateEmbeddedRequest(unclaimedDraftCreateEmbeddedRequest UnclaimedDraftCreateEmbeddedRequest) ApiUnclaimedDraftCreateEmbeddedRequest {
	r.unclaimedDraftCreateEmbeddedRequest = &unclaimedDraftCreateEmbeddedRequest
	return r
}

func (r ApiUnclaimedDraftCreateEmbeddedRequest) Execute() (*UnclaimedDraftCreateResponse, *http.Response, error) {
	return r.ApiService.UnclaimedDraftCreateEmbeddedExecute(r)
}

/*
UnclaimedDraftCreateEmbedded Create Embedded Unclaimed Draft

Creates a new Draft that can be claimed and used in an embedded iFrame. The first authenticated user to access the URL will claim the Draft and will be shown the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a `404`. For this embedded endpoint the `requester_email_address` parameter is required.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnclaimedDraftCreateEmbeddedRequest
*/
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreateEmbedded(ctx context.Context) ApiUnclaimedDraftCreateEmbeddedRequest {
	return ApiUnclaimedDraftCreateEmbeddedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreateEmbeddedExecute(r ApiUnclaimedDraftCreateEmbeddedRequest) (*UnclaimedDraftCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftAPIService.UnclaimedDraftCreateEmbedded")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create_embedded"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unclaimedDraftCreateEmbeddedRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateEmbeddedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateEmbeddedRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest struct {
	ctx context.Context
	ApiService *UnclaimedDraftAPIService
	unclaimedDraftCreateEmbeddedWithTemplateRequest *UnclaimedDraftCreateEmbeddedWithTemplateRequest
}

func (r ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) UnclaimedDraftCreateEmbeddedWithTemplateRequest(unclaimedDraftCreateEmbeddedWithTemplateRequest UnclaimedDraftCreateEmbeddedWithTemplateRequest) ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest {
	r.unclaimedDraftCreateEmbeddedWithTemplateRequest = &unclaimedDraftCreateEmbeddedWithTemplateRequest
	return r
}

func (r ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) Execute() (*UnclaimedDraftCreateResponse, *http.Response, error) {
	return r.ApiService.UnclaimedDraftCreateEmbeddedWithTemplateExecute(r)
}

/*
UnclaimedDraftCreateEmbeddedWithTemplate Create Embedded Unclaimed Draft with Template

Creates a new Draft with a previously saved template(s) that can be claimed and used in an embedded iFrame. The first authenticated user to access the URL will claim the Draft and will be shown the "Request signature" page with the Draft loaded. Subsequent access to the claim URL will result in a `404`. For this embedded endpoint the `requester_email_address` parameter is required.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest
*/
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreateEmbeddedWithTemplate(ctx context.Context) ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest {
	return ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftAPIService) UnclaimedDraftCreateEmbeddedWithTemplateExecute(r ApiUnclaimedDraftCreateEmbeddedWithTemplateRequest) (*UnclaimedDraftCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftAPIService.UnclaimedDraftCreateEmbeddedWithTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/create_embedded_with_template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unclaimedDraftCreateEmbeddedWithTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftCreateEmbeddedWithTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftCreateEmbeddedWithTemplateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnclaimedDraftEditAndResendRequest struct {
	ctx context.Context
	ApiService *UnclaimedDraftAPIService
	signatureRequestId string
	unclaimedDraftEditAndResendRequest *UnclaimedDraftEditAndResendRequest
}

func (r ApiUnclaimedDraftEditAndResendRequest) UnclaimedDraftEditAndResendRequest(unclaimedDraftEditAndResendRequest UnclaimedDraftEditAndResendRequest) ApiUnclaimedDraftEditAndResendRequest {
	r.unclaimedDraftEditAndResendRequest = &unclaimedDraftEditAndResendRequest
	return r
}

func (r ApiUnclaimedDraftEditAndResendRequest) Execute() (*UnclaimedDraftCreateResponse, *http.Response, error) {
	return r.ApiService.UnclaimedDraftEditAndResendExecute(r)
}

/*
UnclaimedDraftEditAndResend Edit and Resend Unclaimed Draft

Creates a new signature request from an embedded request that can be edited prior to being sent to the recipients. Parameter `test_mode` can be edited prior to request. Signers can be edited in embedded editor. Requester's email address will remain unchanged if `requester_email_address` parameter is not set.

**NOTE**: Embedded unclaimed drafts can only be accessed in embedded iFrames whereas normal drafts can be used and accessed on Dropbox Sign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signatureRequestId The ID of the signature request to edit and resend.
 @return ApiUnclaimedDraftEditAndResendRequest
*/
func (a *UnclaimedDraftAPIService) UnclaimedDraftEditAndResend(ctx context.Context, signatureRequestId string) ApiUnclaimedDraftEditAndResendRequest {
	return ApiUnclaimedDraftEditAndResendRequest{
		ApiService: a,
		ctx: ctx,
		signatureRequestId: signatureRequestId,
	}
}

// Execute executes the request
//  @return UnclaimedDraftCreateResponse
func (a *UnclaimedDraftAPIService) UnclaimedDraftEditAndResendExecute(r ApiUnclaimedDraftEditAndResendRequest) (*UnclaimedDraftCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnclaimedDraftCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UnclaimedDraftAPIService.UnclaimedDraftEditAndResend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unclaimed_draft/edit_and_resend/{signature_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"signature_request_id"+"}", url.PathEscape(parameterValueToString(r.signatureRequestId, "signatureRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unclaimedDraftEditAndResendRequest == nil {
		return localVarReturnValue, nil, reportError("unclaimedDraftEditAndResendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unclaimedDraftEditAndResendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
